# C++

## 문제풀이

### 문제 1.

- https://www.acmicpc.net/problem/9493

- 내 풀이

```
#include <iostream>
#include <algorithm>
#include <string>
#include <cmath>

using namespace std;

int main()
{
	while (true)
	{
		float M, A, B;

		cin >> M >> A >> B;
		if (M == 0 && A == 0 && B == 0)
		{
			return 0;
		}

		float result = (M * 60 / A) - (M * 60 / B);

		// result를 60으로 나눈 몫은 시간으로 빼고, 나머지 중 정수부는 분으로 소수부는 60을 곱해서 초로 생각하면 될듯하다.


		string hour = to_string(int(result) / 60);
		string minute = to_string(int(result) % 60);
		string second = to_string(int(round((result - int(result))*60)));

		if (stoi(minute) < 10)
		{
			minute = "0" + minute;
		}

		if (stoi(second) < 10)
		{
			second = "0" + second;
		}

		cout << hour << ":" << minute << ":" << second << endl;
	}
}
```

입출력이 21 70 80일때 2분 15초의 차이가 난다.
21*60/70 = 18분, 21*60/80은 63/4분이기 때문에 2분 15초 차이가 난다.

시간은 그냥 출력하고 분과 초는 두자릿수가 아니면 앞에 0을 붙이게 하였다.
시간은 60으로 나눈 몫을 주고, 분은 60으로 나눈 나머지를 준다. 초는 소수점 부분만 추출한뒤에 60을 곱하고 반올림한것을 integer로 변환하여 출력했다.

- stoi : string을 integer로 변환
- int : 숫자를 int로 감싸서 정수형 변환
- round(x) : 가장 가까운 정수로 반올림
- floor(x) : 소수점 이하 버림
- ceil(x) : 소수점 이하 올림

- 코드 예시에 있는 setw, setfill
- 출력 형식을 지정하는 조정자
- <iomanip> 헤더 파일이 있어야 함
- setw(n)은 출력할 데이터 필드 너비를 n으로 지정, 즉 출력 공간 크기를 미리 예약
- setfill(c)는 말그대로 문자c로 나머지 공간을 채우는 것

### 문제 2.

- 내 풀이

```
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

string solution(string text)
{
	bool isFirst = true;
	for (int i = 0; i < text.length(); i++)
	{
		if (isblank(text[i]))
		{
			isFirst = true;
		}
		else
		{
			if (isFirst)
			{
				text[i] = toupper(text[i]);
				isFirst = false;
			}
			else
			{
				text[i] = tolower(text[i]);
			}
		}
	}

	return text;
}

int main()
{
	string text;
	getline(cin, text);

	text = solution(text);

	cout << text << endl;
}

```

### 문제 3.

- 내 풀이

```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <deque>

using namespace std;

vector<int> solution(int N, int K)
{
	deque<int> q;

	for (int i = 1; i <= N; i++)
	{
		q.push_back(i);
	}

	vector<int> result;
	int cnt = 0;
	while (q.size())
	{
		int tmp = q.front();
		q.pop_front();
		cnt++;
		if (cnt ==  K)
		{
			result.push_back(tmp);
			cnt = 0;
		}
		else
		{
			q.push_back(tmp);
		}
	}
	return result;
}

int main()
{
	vector<int> res = solution(7, 3);

	for (int x : res)
	{
		cout << x << " ";
	}
	cout << "\n";

	vector<int> res2 = solution(5, 2);
	for (int x : res2)
	{
		cout << x << " ";
	}
	cout << "\n";

	return 0;
}
```

- 자료구조별 메소드들의 활용을 조금 더 많이 해봐야 할 것 같다.

## 맵과 셋

- 검색과 중복 방지에 특화
- 레드-블랙 트리로 구현

### 맵

- key, value쌍 저장
- key는 유일해야 함
- 삽입, 삭제, 검색이 평균 O(log N)
  - 내부적으로 이진 탐색 트리(레드-블랙 트리)를 사용하기 때문에!
- insert(pair)
- erase(key)
- find(key)
- operator[key] : 키로 값에 접근 또는 삽입
- size()

```
#include <iostream>
#include <map>
#include <string>

using namespace std;

int main()
{
	map<string, int> score;

	score["rtan"] = 95;
	score["goong"] = 88;
	score.insert({ "yeorerbun", 100 });

	cout << "rtan 점수 : " << score["rtan"] << endl;
	cout << "goong 점수 : " << score.at("goong") << endl;

	if (score.find("tom") == score.end())
	{
		cout << "tom 기록 없음! " << endl;
	}

	score["goong"] = 90;

	for (auto& kv : score)
	{
		cout << kv.first << "의 점수: " << kv.second << endl;
	}
}

```

### 셋

- 키만 저장
- 중복 불가
- 삽입, 삭제, 검색이 평균 O(log N)
- 내부 구조는 map과 동일하다 (레드-블랙트리), 대신 key만 존재
- insert(value);
- erase(value);
- find(value);
- size()
- lower_bound(value) : 지정된 값 이상의 첫 번째 요소를 반환
- upper_bound(value) : 지정된 값보다 큰 첫번째 요소를 반환

```
#include <iostream>
#include <set>

using namespace std;

int main()
{
	set<int> s;

	s.insert(5);
	s.insert(2);
	s.insert(9);
	s.insert(5);

	if (s.find(2) != s.end())
	{
		cout << "2가 존재합니다!!" << endl;
	}

	for (auto& elem : s)
	{
		cout << elem << " ";
	}
	cout << endl;

	s.erase(5);

	auto lb = s.lower_bound(2);
	if (lb != s.end()) cout << "lower_bound(2) : " << *lb << endl;

	auto ub = s.upper_bound(2);
	if (ub != s.end()) cout << "upper_bound(2) : " << *ub << endl;
}

```

### 트리

- 계층적 데이터 구조
  - 부모, 자식 관계로 연결되어 있는 자료구조
  - root, parent, child, leaf, sibling(형제)

#### 이진 탐색 트리

- 작은값 왼쪽서브트리, 크거나 같은값 오른쪽 서브트리
- 한쪽에 편향되는 구조가 될 수 있기때문에 이를 개선한것이 레드-블랙트리

#### 레드-블랙트리

- 균형 유지에 특화된 이진 탐색 트리
- 트리 높이를 log N으로 유지
- 루트 노드는 항상 검정
- 빨강 노드의 자식은 둘다 검정
  - 빨강이 연속되어 나오면 안됨
- 어떤 노드에서 리프까지 가는 모든 경로의 검정 노드 개수는 같다.

- 새로 삽입되는 노드는 항상 레드
- 레드가 연달아 나오는 경우 회전이나 색깔 재설정으로 변경 (디테일은 나중에)
- 탐색, 삽입, 삭제 모두 평균/최악 O(log N)

### multimap, multiset

- 키가 같지만 value가 다른 값을 여럿 저장할 수 있는것

#### multimap

- 같은 키를 중복해서 저장
  - 하나의 키에 여러개의 value가능
- insert(pair)
- erase(key)
- find(key)
- equal_range(key) : 동일한 키의 요소 범위를 반환

```
#include <iostream>
#include <map>

using namespace std;

int main()
{
	multimap<int, string> mm;

	mm.insert({ 1, "rtan" });
	mm.insert({ 1, "goong" });
	mm.insert({ 2, "tom" });

	// 키가 1인 모든 원소 조회
	auto range = mm.equal_range(1);
	for (auto it = range.first; it != range.second; ++it)
	{
		cout << it->second << " ";
	}
	cout << endl;
}

```

#### multiset

- 동일한 값(키) 중복을 허용하는 셋
- insert(value)
- erase(value)
- find(value)

```
#include <iostream>
#include <set>

using namespace std;

int main()
{
	multiset<int> ms;

	ms.insert(10);
	ms.insert(20);
	ms.insert(10);

	for (int elem : ms)
	{
		cout << elem << " ";
	}

	cout << endl;
}

```

##### multiset을 왜 사용하지??

- 원소들이 항상 정렬된 상태로 유지되고
- 탐색, 삽입, 삭제가 log N으로 빠르기 때문에 사용

### 문제 풀이

- 내 풀이

```
#include <iostream>
#include <set>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
	int N;
	cin >> N;

	map<string, int> newMap;
	vector<pair<string, int>> vec;

	for (int i = 0; i < N; i++)
	{
		string inp;
		cin >> inp;
		newMap[inp]++;
	}

	for (auto& m : newMap)
	{
		vec.push_back({ m.first, m.second });
	}

	sort(vec.begin(), vec.end(), [](auto& a, auto& b) {
		if (a.second != b.second)
		{
			return a.second > b.second;
		}
		return a.first < b.first;
		});

	int rank = 0;
	int cnt = -1;

	for (int i = 0; i < vec.size(); i++)
	{
		string v = vec[i].first;
		int vCnt = vec[i].second;

		if (vCnt != cnt)
		{
			rank = i + 1;
			cnt = vCnt;
		}

		cout << v << ":" << rank << "\n";
	}

	return 0;

}

```

- C++의 map에서는 newMap[inp]++; 했을때 inp키에 해당하는 값이 없으면 0으로 자동 생성됨
- sort 조건을 다양하게 활용할 수 있음
