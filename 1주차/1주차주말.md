## C++ 익숙해지기

- 다양한 stl을 잘 섞어쓰면 굉장히 좋다.

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

int main() {
	vector<int> v = { 5, 2, 9, 1, 7 };

	sort(v.begin(), v.end());

	if (binary_search(v.begin(), v.end(), 9))
	{
		cout << "9가 벡터에 있습니다!" << endl;
	}

	int sum = accumulate(v.begin(), v.end(), 0);
	cout << "벡터 원소들의 합 = " << sum << endl;

	replace(v.begin(), v.end(), 1, 100);

	sum = accumulate(v.begin(), v.end(), 0);
	cout << "벡터 원소들의 합2 = " << sum << endl;

	return 0;
}
```

## 문제 풀어보기

---

_Q. `n`개의 정수를 입력받아 벡터에 저장한 후, 연산 결과를 출력하세요. 사용자는 `q`개의 질의를 입력할 수 있게 합니다. 각 질의는 두 개의 정수 `l`과 `r`로 구성되며, 이는 벡터의 구간 `[l, r]`의 합을 계산하라는 의미입니다._

_힌트: `accumulate` 함수를 사용해보세요! (15분)_

**입력 예제**

```
5 // 벡터 크기
1 2 3 4 5 // 벡터에 저장되는 정수들
3 // 질의 개수
1 3 // 질의 1
2 5 // 질의 2
1 5 // 질의 3
```

**출력 예제**

```
6 // 1 3에 대한 출력 (1, 2, 3을 더해서 6)
14 // 2 5에 대한 출력 (2, 3, 4, 5를 더해서 14)
15 // 1 5에 대한 출력 (1, 2, 3, 4, 5를 더해서 15)
```

- 내 풀이

```
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

int main() {
	int N;
	cin >> N;

	vector<int> v;
	for (int i = 0; i < N; i++)
	{
		int inp;
		cin >> inp;
		v.push_back(inp);
	}

	int q;
	cin >> q;
	for (int i = 0; i < q; i++) {
		int l;
		cin >> l;
		int r;
		cin >> r;

		l--;
		int out = accumulate(v.begin() + l, v.begin() + r, 0);
		cout << out << endl;
	}

	return 0;
}

```

## 문자열 기초

- islower
- isupper
- isdigit
- isxdigit
- iscntrl
  - 제어문자 (출력되지 않는 문자) \t, \n, \0등
- isgraph
  - 공백제외한 모든 출력 가능 문자
- isspace
  - 공백문자인지
- isblank
  - 가로 공백만 가능 ' ' , \t
- isprint
  - 출력 가능한 문자인지 확인
  - isgraph + 공백( ) 포함
- ispunct

  - 구두점(특수문자)인지 확인

### 문제

- Q. 문자열 S가 주어졌을 때, 알파벳 대소문자/숫자/공백의 개수를 각각 센 뒤 출력하는 프로그램을 작성해주세요. (10분)

```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	string sp = "Hello World 123!";

	int upperCnt = 0;
	int lowerCnt = 0;
	int digitCnt = 0;
	int spaceCnt = 0;
	int cnt = 0;

	for (int i = 0; i < sp.length(); i++)
	{
		if (isupper(sp[i]))
		{
			upperCnt++;
		}
		else if (islower(sp[i]))
		{
			lowerCnt++;
		}
		else if (isdigit(sp[i]))
		{
			digitCnt++;
		}
		else if (isblank(sp[i]))
		{
			spaceCnt++;
		}
		else
		{
			cnt++;
		}
	}

	cout << upperCnt << endl;
	cout << lowerCnt << endl;
	cout << digitCnt << endl;
	cout << spaceCnt << endl;
	cout << cnt << endl;

	return 0;
}

```

- reverse메소드

```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
	string S = "Hello World!";
	reverse(S.begin(), S.end());

	// swap을 사용하는 경우
	/*for (int i = 0; i < S.length()/2; i++)
	{
		swap(S[i], S[S.length() - 1 - i]);
	}*/
	cout << S << endl;

	return 0;
}

```

- 단어 추출
  - <sstream>의 istringstream을 사용

```
#include <iostream>
#include <sstream>
#include <vector>
#include <string>

using namespace std;

int main()
{
	string text = "Hello, my name is JongKyu";
	istringstream iss(text);
	vector<string> words;
	string token;

	while (iss >> token)
	{
		words.push_back(token);
	}

	for (auto& w : words)
	{
		cout << w << "\n";
	}
}

```

- 빈도수 계산

```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

int main()
{
	string S = "banana";
	unordered_map<char, int> freq;

	for (char c : S)
	{
		freq[c]++;
	}

	vector<pair<char, int>> vec;
	for (auto& p : freq)
	{
		vec.push_back({ p.first, p.second });
	}

	sort(vec.begin(), vec.end(), [](auto& a, auto& b) {
		return a.second > b.second;
		});

	string result;
	for (auto& p : vec)
	{
		result.append(p.second, p.first);
	}

	cout << "빈도 내림차순 정렬 결과 : " << result << endl;
}

```

### 문제

- Q. 문자열 S에서, 짝수 인덱스 문자들만 사전순 오름차순, 홀수 인덱스 문자들만 사전순 내림차순으로 재정렬한 새로운 문자열을 만들어보세요. (15분)

- 내 풀이

```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

using namespace std;

int main()
{
	vector<char> even;
	vector<char> odd;
	string S = "AppleBanana";

	int N = S.length();
	for (int i = 0; i < N; i++)
	{
		if (i % 2)
		{
			odd.push_back(S[i]);
		}
		else
		{
			even.push_back(S[i]);
		}
	}
	sort(even.begin(), even.end());
	sort(odd.begin(), odd.end(), [](auto& a, auto& b) {
		return a > b;
		});

	string newS = "";

	if (even.size() > odd.size())
	{
		for (int i = 0; i < odd.size(); i++)
		{
			newS += even[i];
			newS += odd[i];
		}
		newS += even[even.size() - 1];
	}
	else{
		for (int i = 0; i < even.size(); i++)
		{
			newS += even[i];
			newS += odd[i];
		}
	}

	cout << newS << endl;
}

```

## 문제 풀어보기 (15분)

---

[](https://school.programmers.co.kr/learn/courses/30/lessons/12951)

### **문제 설명**

JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 단, 첫 문자가 알파벳이 아닐 때에는 이어지는 알파벳은 소문자로 쓰면 됩니다. (첫 번째 입출력 예 참고)

문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.

### 제한 조건

- s는 길이 1 이상 200 이하인 문자열입니다.
- s는 알파벳과 숫자, 공백문자(" ")로 이루어져 있습니다.
  - 숫자는 단어의 첫 문자로만 나옵니다.
  - 숫자로만 이루어진 단어는 없습니다.
  - 공백문자가 연속해서 나올 수 있습니다.

### 입출력 예

| s                       | return                  |
| ----------------------- | ----------------------- |
| "3people unFollowed me" | "3people Unfollowed Me" |
| "for the last week"     | "For The Last Week"     |

- 내 풀이

```
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <sstream>
#include <cctype>

using namespace std;

int main()
{
	string inpString;
	getline(cin, inpString);

	bool flag = false;

	for (char& inp : inpString)
	{
		if (inp == ' ')
		{
			flag = true;
		}
		else if (flag)
		{
			if (isalpha(inp))
			{
				inp = toupper(inp);
			}
			flag = false;
		}
		else {
			inp = tolower(inp);
		}
	}

	cout << inpString << endl;
}
```

#### 궁금한거

- c++에서 그냥 map은 정렬을 자동으로 시키는데 조건이 뭔지?
  - key를 기준으로 오름차순 정렬
- pair는 무슨 자료형인지?
  - pair는 두개의 값을 하나로 묶어주는 구조체 역할
  - map이나 unordered_map은 내부적으로 데이터를 저장할때 pair로 저장
  - 구조체 멤버 변수가 first, second로 정의되어서 p.first 같은 형태로 접근가능
- 정렬시 조건에 대괄호 의미
  - 람다 표현식
  - 외부 변수 캡처용, [], [=] : 외부변수들 값으로 복사해서 사용, [&] : 외부 변수들 참조로 사용
  - 일단 알고만 있자
