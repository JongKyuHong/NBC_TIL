## 언리얼

### 그냥 아무거나 만들면서 익숙해지기

오늘은 움직이는 벽, 상호작용 가능한 큐브, trigger한번 다시 만들어 보면서 익숙해지는 시간을 가졌다.

## 언리얼 공식 유튜브에서 영상 시청하고 소감 남기기

https://www.youtube.com/watch?v=BxgJn9jtc4w

- 위쳐3에서 4로 차기작이 나오면서 CDPR자체 엔진에서 언리얼5로 넘어오게 되었다.
- 유저들의 게임플레이 경험을 고려하는 부분이 인상깊었습니다.

  - 현세대 콘솔에서도 오픈월드를 60프레임이상으로 돌릴 수 있게
  - 60프레임을 넘겨놓아야 전투씬 중에 최대한 60프레임방어가 가능, 또 그것이 가능하도록 최대한 cpu쪽에 여유를 두고 개발
  - 시각적인 요소도 현세대 콘솔에서 최대한 발휘할수 있게끔
  - 조금이라도 끊기면 유저들의 몰입이 떨어지기 때문에 최대한 끊기는 부분 없도록

- 다양한 최적화 기법을 고려하는것이 인상깊었습니다.
  - 나무들을 조합해서 재사용하여 최대한 메모리 효율을 높임

## C++

- getline으로 한줄 입력 가능, string헤더에 포함되어 있다.
- switch-case

  ```
  switch(n)
  {
      case 1: cout << "one"; break;
      case 2: cout << "two"; break;
      default: cout << "Other"; break;
  }
  ```

  - switch-case문에서 break쓰는거 잊지

- 레퍼런스
  ```
  int x = 10;
  int& ref = x;
  ref = 20;
  cout << x; // 20
  ```
  - 레퍼런스는 변수의 별명

#### 레퍼런스를 왜 사용하는가??

1\. 복사 비용을 줄이기 위해

- C++은 변수를 함수에 넘길때 기본적으로 값 전체를 복사하는데 함수의 매개변수로 레퍼런스를 넘겨주면 값의 주소를 전달하기 때문에 효율적이다.

2\. 동시에 여러값을 수정하고 싶을 때

```
void swap(int a, int b) {
    int tmp = a;
    a = b;
    b = tmp;
}

int main() {
    int x = 10, y = 20;
    swap(x, y);
    cout << x << " " << y; // 안바뀐다.
}
```

- swap의 매개변수가 int& a, int& b로 레퍼런스라면 값은 정상적으로 스왑된다.

#### 메모리 누수

- new로 할당한 배열은 delete로 직접 메모리를 해제하지 않으면 메모리 누수(leak)가 생긴다.
- 해제하지 않으면 램의 힙공간을 계속해서 차지하고 그 메모리 주소를 아무도 모르게 되어 유령 메모리가 된다.
- 실제로 프로그램이 종료되면 운영체제에서 그 프로그램이 쓰던 메모리를 자동 회수하는데 만약에 프로그램이 계속 실행되고있는데 메모리 누수가 발생하면 게임이 느려지거나 크래시되는등 문제가 생길 수 있다.

#### 댕글링 포인터

- 포인터는 이미 해제된 메모리를 가리키면 문제가 생기므로 delete로 메모리를 해제한다면 꼭 포인터 변수도 nullptr로 초기화 해주어야 한다.
